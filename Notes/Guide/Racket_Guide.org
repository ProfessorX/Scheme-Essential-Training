# This is the "e-notebook" for Racket Guide. 
# Collected and summarized by Abraham Xiao. Original copyrights belong
# to Matthew Flatt and PLT team. For this document, refer to the
# repository LICENSE.
* The Racket Guide

** Racket Essentials
   - Under the hood, a function definition is really the same as a
     non-function definition, and a function name does not have to be
     used in a function call. A function is just another kind of
     value, though the printed form is necessarily less complete than
     the printed form of a number or string.
   - A function definition can include multiple expressions for the
     function’s body. In that case, only the value of the last
     expression is returned when the function is called.
   - For function calls, the first <expr> can be anything that
     evaluates to a function. For example, it can be a conditional
     expression.
   - In Racket, you can use a lambda expression to produce a function
     directly. The lambda form is followed by identifiers for the
     function’s arguments, and then the function’s body expressions.
   - The body of a Racket iteration is packaged into a function to be
     applied to each element, so the lambda form becomes particularly
     handy in combination with iteration functions.
   - The cons function actually accepts any two values, not just a
     list for the second argument. When the second argument is not
     empty and not itself produced by cons, the result prints in a
     special way. The two values joined with cons are printed between
     parentheses, but with a dot (i.e., a period surrounded by
     whitespace) in between
   - In the same way that parenthesized output should not be confused
     with expressions, a printed symbol should not be confused with
     an identifier. In particular, the symbol (quote map) has nothing
     to do with the map identifier or the predefined function that is
     bound to map, except that the symbol and the identifier happen
     to be made up of the same letters.
   - The syntax of Racket is not defined directly in terms of
     character streams. Instead, the syntax is determined by two
     layers:
     - a reader layer, which turns a sequence of characters into
       lists, symbols, and other constants
     - an expander layer, which processes the lists, symbols, and
       other constants to parse them as an expression.



** Built-In Datatypes
   - Racket has two distinguished constants to represent boolean
     values: #t for true and #f for false. Uppercase #T and #F are
     parsed as the same values, but the lowercase forms are
     preferred.
   - Inexact numbers print with a decimal point or exponent specifier,
     and exact numbers print as integers and fractions. The same
     conventions apply for reading number constants, but #e or #i can
     prefix a number to force its parsing as an exact or inexact
     number. The prefixes #b, #o, and #x specify binary, octal, and
     hexadecimal interpretation of digits.
   - The = procedure compares numbers for numerical equality. If it is
     given both inexact and exact numbers to compare, it essentially
     converts the inexact numbers to exact before com- paring. The
     eqv? (and therefore equal?) procedure, in contrast, compares
     numbers considering both exactness and numerical equality.
   - Beware of comparisons involving inexact numbers, which by their
     nature can have surprising behavior. Even apparently simple
     inexact numbers may not mean what you think they mean; for
     example, while a base-2 IEEE floating-point number can represent
     1/2 exactly, it can only approximate 1/10.
   - A printable character normally prints as #\ followed by the
     represented character. An un- printable character normally prints
     as #\u followed by the scalar value as hexadecimal num- ber. A
     few characters are printed specially; for example, the space and
     linefeed characters print as #\space and #\newline,
     respectively.
   - A string can be mutable or immutable; strings written directly as
     expressions are immutable, but most other strings are
     mutable. The make-string procedure creates a mutable string given
     a length and optional fill character. The string-ref procedure
     accesses a character from a string (with 0-based indexing); the
     string-set! procedure changes a character in a mutable string.
   - For any sequence of characters, exactly one corresponding symbol
     is interned; calling the string->symbol procedure, or reading a
     syntactic identifier, produces an interned symbol. Since interned
     symbols can be cheaply compared with eq? (and thus eqv? or
     equal?), they serve as a convenient values to use for tags and
     enumerations.
   - Actually, # is disallowed only at the beginning of a symbol, and
     then only if not followed by %; otherwise, # is allowed,
     too. Also, . by itself is not a symbol.
   - Keywords are intended for use (unquoted) as special markers in
     argument lists and in certain syntactic forms. For run-time flags
     and enumerations, use symbols instead of keywords.
   - A pair joins two arbitrary values. The cons procedure constructs
     pairs, and the car and cdr procedures extract the first and
     second elements of the pair, respectively. The pair? predicate
     recognizes pairs.
   - A list is a combination of pairs that creates a linked list. More
     precisely, a list is either the empty list null, or it is a pair
     whose first element is a list element and whose second element is
     a list. The list? predicate recognizes lists. The null? predicate
     recognizes the empty list. (*Fuck this recursive definition)*
   - Pairs are immutable (contrary to Lisp tradition), and pair? and
     list? recognize immutable pairs and lists, only. The mcons
     procedure creates a mutable pair, which works with set- mcar! and
     set-mcdr!, as well as mcar and mcdr. A mutable pair prints using
     mcons, while write and display print mutable pairs with { and }.
   - When allocating extra lists seems too expensive, consider using
     looping forms like for/fold, which recognize vectors as well as
     lists.
   - The hash, hasheqv, and hasheq functions create immutable hash
     tables from an initial set of keys and values, in which each
     value is provided as an argument after its key. Immutable hash
     tables can be extended with hash-set, which produces a new
     immutable hash table in constant time.
   - A literal immutable hash table can be written as an expression by
     using #hash (for an equal?-based table), #hasheqv (for an
     eqv?-based table), or #hasheq (for an eq?-based table). A
     parenthesized sequence must immediately follow #hash, #hasheq, or
     #hasheqv, where each element is a dotted key–value pair.
   - Beware that even a weak hash table retains its values strongly,
     as long as the corresponding key is accessible. This creates a
     catch-22 dependency when a value refers back to its key, so that
     the mapping is retained permanently. To break the cycle, map the
     key to an ephemeron that pairs the value with its key (in
     addition to the implicit pairing of the hash table).
   -

** Expressions and Definitions
   - Forms like define, lambda, and let associate a meaning with one
     or more identifiers; that is, they bind identifiers. The part of
     the program for which the binding applies is the scope of the
     binding. The set of bindings in effect for a given expression is
     the expression’s environment.
   - As a convenience, the apply function accepts additional arguments
     between the function and the list. The additional arguments are
     effectively consed onto the argument list.
   - Instead of just an identifier, an argument (other than a rest
     argument) in a lambda form can be specified with an identifier
     and a default value.
   - The function supplied to make-keyword-procedure receives keyword
     arguments through parallel lists in the first two (by-position)
     arguments, and then all by-position arguments from an
     application as the remaining by-position arguments.
   - In a sense, make-add-suffix is a function takes two arguments,
     but it takes them one at a time. A function that takes some of
     its arguments and returns a function to consume more is sometimes
     called a curried function.
   - 


















 
